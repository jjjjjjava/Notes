[toc]



## 自旋锁

### 介绍

### SylixOS中的自旋锁

```
/*********************************************************************************************************
  spinlock types.
*********************************************************************************************************/
#ifdef __SYLIXOS_KERNEL

typedef union {
    volatile UINT32 SLD_uiLock;
    
    struct {
#if LW_CFG_CPU_ENDIAN > 0
        UINT16      SLDQ_usTicket;
        UINT16      SLDQ_usSvcNow;
#else
        UINT16      SLDQ_usSvcNow;
        UINT16      SLDQ_usTicket;
#endif                                                                  /*  LW_CFG_CPU_ENDIAN           */
    } q;
#define SLD_usTicket    q.SLDQ_usTicket
#define SLD_usSvcNow    q.SLDQ_usSvcNow
} SPINLOCKTYPE;

#define LW_SPINLOCK_TICKET_SHIFT    16

#endif                                                                  /*  __SYLIXOS_KERNEL            */






/*********************************************************************************************************
  spinlock_t
*********************************************************************************************************/

#ifdef __SYLIXOS_KERNEL
struct __lw_cpu;
#endif                                                                  /*  __SYLIXOS_KERNEL            */

typedef struct {
#ifdef __SYLIXOS_KERNEL
    SPINLOCKTYPE                SL_sltData;                             /*  自旋锁                      */
#define SL_uiLock               SL_sltData.SLD_uiLock
#define SL_usTicket             SL_sltData.SLD_usTicket
#define SL_usSvcNow             SL_sltData.SLD_usSvcNow
    volatile struct __lw_cpu   *SL_pcpuOwner;                           /*  CPU 标识                    */

#else
    volatile UINT32             SL_uiLock;                              /*  自旋锁                      */
    volatile PVOID              SL_pcpuOwner;
#endif                                                                  /*  __SYLIXOS_KERNEL            */
    
    ULONG                       SL_ulCounter;                           /*  锁定计数器                  */
    PVOID                       SL_pvReserved;                          /*  保留                        */
} spinlock_t;

#define LW_SPINLOCK_DEFINE(sl)              spinlock_t  sl
#define LW_SPINLOCK_DECLARE(sl)             spinlock_t  sl
```



## Cpu

### SylixOS中Cpu结构

```
/*********************************************************************************************************
  CPU 结构 (要求 CPU ID 编号从 0 开始并由连续数字组成) 
  TODO: CPU_cand, CPU_slIpi 独立组成数组 CACHE 效率高?
*********************************************************************************************************/
#ifdef  __SYLIXOS_KERNEL

typedef struct __lw_cpu {
    /*
     *  运行线程情况
     */
    PLW_CLASS_TCB            CPU_ptcbTCBCur;                            /*  当前 TCB                    */
    PLW_CLASS_TCB            CPU_ptcbTCBHigh;                           /*  需要运行的高优先 TCB        */
    
#if LW_CFG_COROUTINE_EN > 0
    /*
     *  协程切换信息
     */
    PLW_CLASS_COROUTINE      CPU_pcrcbCur;                              /*  当前协程                    */
    PLW_CLASS_COROUTINE      CPU_pcrcbNext;                             /*  需要切换的目标协程          */
#else
    PVOID                    CPU_pvNull[2];                             /*  保证下面成员地址偏移量一致  */
#endif                                                                  /*  LW_CFG_COROUTINE_EN > 0     */

    /*
     *  当前发生调度的调度方式
     */
    BOOL                     CPU_bIsIntSwitch;                          /*  是否为中断调度              */

    /*
     *  候选运行结构
     */
    LW_CLASS_CAND            CPU_cand;                                  /*  候选运行的线程              */

    /*
     *  内核锁定状态
     */
    INT                      CPU_iKernelCounter;                        /*  内核状态计数器              */

    /*
     *  当前核就绪表
     */
#if LW_CFG_SMP_EN > 0
    LW_CLASS_PCBBMAP         CPU_pcbbmapReady;                          /*  当前 CPU 就绪表             */
    BOOL                     CPU_bOnlyAffinity;                         /*  是否仅运行亲和线程          */
    
#if LW_CFG_CACHE_EN > 0
    volatile BOOL            CPU_bCacheBarStart;                        /*  CACHE 起始同步点            */
    volatile BOOL            CPU_bCacheBarEnd;                          /*  CACHE 结束同步点            */
#endif                                                                  /*  LW_CFG_CACHE_EN > 0         */
    
    /*
     *  核间中断待处理标志, 这里最多有 ULONG 位数个核间中断类型, 和 CPU 硬件中断向量原理相同
     */
    LW_SPINLOCK_DEFINE      (CPU_slIpi);                                /*  核间中断锁                  */
    PLW_LIST_RING            CPU_pringMsg;                              /*  自定义核间中断参数链        */
    volatile UINT            CPU_uiMsgCnt;                              /*  自定义核间中断数量          */
    
    ULONG                    CPU_ulIPIVector;                           /*  核间中断向量                */
    FUNCPTR                  CPU_pfuncIPIClear;                         /*  核间中断清除函数            */
    PVOID                    CPU_pvIPIArg;                              /*  核间中断清除参数            */
    
    INT64                    CPU_iIPICnt;                               /*  核间中断次数                */
    atomic_t                 CPU_iIPIPend;                              /*  核间中断标志码              */

#define LW_IPI_NOP              0                                       /*  测试用核间中断向量          */
#define LW_IPI_SCHED            1                                       /*  调度请求                    */
#define LW_IPI_DOWN             2                                       /*  CPU 停止工作                */
#define LW_IPI_PERF             3                                       /*  性能分析                    */
#define LW_IPI_CALL             4                                       /*  自定义调用 (有参数可选等待) */

#define LW_IPI_NOP_MSK          (1 << LW_IPI_NOP)
#define LW_IPI_SCHED_MSK        (1 << LW_IPI_SCHED)
#define LW_IPI_DOWN_MSK         (1 << LW_IPI_DOWN)
#define LW_IPI_PERF_MSK         (1 << LW_IPI_PERF)
#define LW_IPI_CALL_MSK         (1 << LW_IPI_CALL)

#ifdef __LW_SPINLOCK_BUG_TRACE_EN
    ULONG                    CPU_ulSpinNesting;                         /*  spinlock 加锁数量           */
#endif                                                                  /*  __LW_SPINLOCK_BUG_TRACE_EN  */
    
    /*
     *  CPU 基本信息
     */
#if LW_CFG_CPU_ARCH_SMT > 0
             ULONG           CPU_ulPhyId;                               /*  Physical CPU Id             */
#endif                                                                  /*  LW_CFG_CPU_ARCH_SMT         */
#if LW_CFG_CPU_ARCH_HETRC > 0
             ULONG           CPU_ulHccId;                               /*  Hetr Computiong Cluster Id  */
#endif                                                                  /*  LW_CFG_SMP_HETEROGENEOUS... */
#endif                                                                  /*  LW_CFG_SMP_EN > 0           */

             ULONG           CPU_ulCPUId;                               /*  CPU ID 号                   */
    volatile ULONG           CPU_ulStatus;                              /*  CPU 工作状态                */

    /*
     *  中断信息
     */
    PLW_STACK                CPU_pstkInterBase;                         /*  中断堆栈基址                */
    ULONG                    CPU_ulInterNesting;                        /*  中断嵌套计数器              */
    ULONG                    CPU_ulInterNestingMax;                     /*  中断嵌套最大值              */
    ULONG                    CPU_ulInterError[LW_CFG_MAX_INTER_SRC];    /*  中断错误信息                */
    
#if (LW_CFG_CPU_FPU_EN > 0) && (LW_CFG_INTER_FPU > 0)
    /*
     *  中断时使用的 FPU 上下文. 
     *  只有 LW_KERN_FPU_EN_GET() 有效时才进行中断状态的 FPU 上下文操作.
     */
    LW_FPU_CONTEXT           CPU_fpuctxContext[LW_CFG_MAX_INTER_SRC];   /*  中断时使用的 FPU 上下文     */
#endif                                                                  /*  LW_CFG_CPU_FPU_EN > 0       */
                                                                        /*  LW_CFG_INTER_FPU > 0        */

#if (LW_CFG_CPU_DSP_EN > 0) && (LW_CFG_INTER_DSP > 0)
    /*
     *  中断时使用的 DSP 上下文.
     *  只有 LW_KERN_DSP_EN_GET() 有效时才进行中断状态的 DSP 上下文操作.
     */
    LW_DSP_CONTEXT           CPU_dspctxContext[LW_CFG_MAX_INTER_SRC];   /*  中断时使用的 DSP 上下文     */
#endif                                                                  /*  LW_CFG_CPU_DSP_EN > 0       */
                                                                        /*  LW_CFG_INTER_DSP > 0        */
} LW_CLASS_CPU;
typedef LW_CLASS_CPU        *PLW_CLASS_CPU;

```

